"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchMetro = exports.shouldEnableRetryResolvingFromDisk = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const helper_1 = require("../helper");
function fileExists(path) {
    const stat = fs.statSync(path, { throwIfNoEntry: false });
    return Boolean(stat && stat.isFile());
}
function importMetroModule(path) {
    const metroPath = (0, helper_1.ensureResolveFrom)("metro", (0, helper_1.getMetroSearchPath)());
    const modulePath = metroPath + path;
    try {
        return require(modulePath);
    }
    catch (_) {
        throw new Error(`Cannot find '${modulePath}'. This probably means that ` +
            "'experimental_retryResolvingFromDisk' is not compatible with the " +
            "version of 'metro' that you are currently using. Please update to " +
            "the latest version and try again. If the issue still persists after " +
            "the update, please file a bug at " +
            "https://github.com/microsoft/rnx-kit/issues.");
    }
}
function getDependencyGraph() {
    return importMetroModule("/src/node-haste/DependencyGraph");
}
function supportsRetryResolvingFromDisk() {
    const { version } = importMetroModule("/package.json");
    const [major, minor] = version.split(".");
    const v = major * 1000 + minor;
    return v >= 64 && v <= 75;
}
function shouldEnableRetryResolvingFromDisk({ experimental_retryResolvingFromDisk, }) {
    if (experimental_retryResolvingFromDisk &&
        experimental_retryResolvingFromDisk !== "force" &&
        !supportsRetryResolvingFromDisk()) {
        console.warn("The version of Metro you're using has not been tested with " +
            "`experimental_retryResolvingFromDisk`. If you still want to enable " +
            "it, please set it to 'force'.");
        return false;
    }
    return Boolean(experimental_retryResolvingFromDisk);
}
exports.shouldEnableRetryResolvingFromDisk = shouldEnableRetryResolvingFromDisk;
/**
 * Monkey-patches Metro to not use HasteFS as the only source for module
 * resolution.
 *
 * Practically every file system operation in Metro must go through HasteFS,
 * most notably watching for file changes and resolving node modules. If Metro
 * cannot find a file in the Haste map, it does not exist. This means that for
 * Metro to find a file, all folders must be declared in `watchFolders`,
 * including `node_modules` and any dependency storage folders (e.g. pnpm)
 * regardless of whether we need to watch them. In big monorepos, this can
 * easily overwhelm file watchers, even with Watchman installed.
 *
 * There's no way to avoid the initial crawling of the file system. However, we
 * can drastically reduce the number of files that needs to be crawled/watched
 * by not relying solely on Haste for module resolution. This requires patching
 * Metro to use `fs.existsSync` instead of `HasteFS.exists`. With this change,
 * we can list only the folders that we care about in `watchFolders`. In some
 * cases, like on CI, we can even set `watchFolders` to an empty array to limit
 * watched files to the current package only.
 *
 * Why didn't we use `hasteImplModulePath`? Contrary to the name, it doesn't
 * let you replace HasteFS. As of 0.73, it is only used to retrieve the path of
 * a module. The default implementation returns
 * `path.relative(projectRoot, filePath)` if the entry is not found in the map.
 *
 * @param options Options passed to Metro
 */
function patchMetro(options) {
    if (!shouldEnableRetryResolvingFromDisk(options)) {
        return;
    }
    const DependencyGraph = getDependencyGraph();
    // Patch `_createModuleResolver` and `_doesFileExist` to use `fs.existsSync`.
    DependencyGraph.prototype.orig__createModuleResolver =
        DependencyGraph.prototype._createModuleResolver;
    DependencyGraph.prototype._createModuleResolver = function () {
        const hasteFS = this._fileSystem || // >= 0.73.5
            this._snapshotFS || // 0.73.4
            this._hasteFS; // < 0.73.4
        this._doesFileExist = (filePath) => {
            return hasteFS.exists(filePath) || fileExists(filePath);
        };
        this.orig__createModuleResolver();
        if (typeof this._moduleResolver._options.resolveAsset !== "function") {
            throw new Error("Could not find `resolveAsset` in `ModuleResolver`");
        }
        this._moduleResolver._options.resolveAsset = (dirPath, assetName, extension) => {
            const basePath = dirPath + path.sep + assetName;
            const assets = [
                basePath + extension,
                ...this._config.resolver.assetResolutions.map((resolution) => basePath + "@" + resolution + "x" + extension),
            ].filter(this._doesFileExist);
            return assets.length ? assets : null;
        };
    };
    // Since we will be resolving files outside of `watchFolders`, their hashes
    // will not be found. We'll return the `filePath` as they should be unique.
    DependencyGraph.prototype.orig_getSha1 = DependencyGraph.prototype.getSha1;
    DependencyGraph.prototype.getSha1 = function (filePath) {
        try {
            return this.orig_getSha1(filePath);
        }
        catch (e) {
            // `ReferenceError` will always be thrown when Metro encounters a file
            // that does not exist in the Haste map.
            if (e instanceof ReferenceError) {
                return filePath;
            }
            throw e;
        }
    };
}
exports.patchMetro = patchMetro;
//# sourceMappingURL=patchMetro.js.map